(*
The MIT License (MIT)
Copyright (c) 2025 [WE THE DEVS].

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *)

(*
 * Project      : ANTLR4 lexer grammar for NeoBASIC programming language.
 *                https://github.com/neobasic
 * Developed by : Raul Bras, @teknolista.
 *)

(* SOURCE CODE ORGANIZATION OF NEOBASIC PROGRAM *)

NeobProgram = OneLinerProgram | AlgorithmProgram .

AlgorithmProgram = ( ProcessProgram | NotabeneProgram ) EOF .

ProcessProgram = IdentificationDivision EnvironmentDivision ProcessingDivision TestingDivision .

NotabeneProgram =  IdentificationDivision NoteDivision BookDivision .

OneLinerProgram = Statement .


(* ------------------------------------------------------------------------- *)


(* IDENTIFICATION DIVISION *)

IdentificationDivision = { IdentificationStatement EOL } .

IdentificationStatement = IdentityStatement 
                        | CommentedStatement .

IdentityStatement = { DirectiveStatement }
                    ( ModuleSentence | AppletSentence | NotabeneSentence ) .


(* UNIT PROCESS PROGRAMS *)

ModuleSentence = MODULE ModuleName .

ModuleName = NamespaceIdentifier .


(* APPLET PROCESS PROGRAMS *)

AppletSentence = APPLET AppletName .

AppletName = Identifier .


(* NOTA BENE PROGRAMS *)

NotabeneSentence = NOTABENE NotabeneName NotabeneVersion .

NotabeneName = NamespaceIdentifier .

NotabeneVersion = NumberLiteral .


(* ------------------------------------------------------------------------- *)


(* ENVIRONMENT DIVISION *)

EnvironmentDivision = { EnvironmentStatement EOL } .

EnvironmentStatement = UseSentence
                     | InterfaceSentence
                     | IncludeSentence
                     | CommentedStatement .


(* USE SENTENCE *)

UseSentence = USE ( UseDeclares | UseSuite ) .

UseSuite = EOL Indent UseDeclaresList Dedent .

UseDeclaresList = UseDeclares { EOL UseDeclares } .

UseDeclares = UseDeclare { "," UseDeclare } .

UseDeclare = ModuleName
           | ModuleMember
           | ModuleAsClause
           | ModuleOfClause .

ModuleMember = NamespaceIdentifier .

ModuleAsClause = ModuleName AS Identifier .

ModuleOfClause = Identifiers OF ModuleName . 


(* INCLUDE SENTENCE *)

IncludeSentence = INCLUDE ( IncludeDeclares | IncludeSuite ) . 

IncludeSuite = EOL Indent IncludeDeclaresList Dedent .

IncludeDeclaresList = IncludeDeclares { EOL IncludeDeclares } . 

IncludeDeclares = IncludeDeclare { "," IncludeDeclare } .

IncludeDeclare = ShellExpression
               | IncludeAsClause .

IncludeAsClause = ShellExpression AS Identifier .


(* INTERFACE SENTENCE *)

InterfaceSentence = INTERFACE SymbolIdentifier ( ApiClause | MixinSentence ) InterfaceBody .

ApiClause = ":" ApiType StringLiteral .

ApiType = SOCKET | HTTP | HTTPS | REST | SOAP | GRPC | AMQP | FTP | SMTP | IMAP | POP3 .

InterfaceBody = EOL Indent InterfaceMemberDeclaresList Dedent .

InterfaceMemberDeclaresList = InterfaceMemberDeclares { EOL InterfaceMemberDeclares } .

InterfaceMemberDeclares = InterfaceMemberDeclare { "," InterfaceMemberDeclare } .

InterfaceMemberDeclare = MixinSentence
                       | RpcMethodDeclare
                       | ExternMethodDeclare .

MixinSentence = MIXIN Types .

RpcMethodDeclare = RPROC SymbolIdentifier RpcParameters RpcResult .

RpcParameters = "(" [ Types ] ")" .

RpcResult = Type .

ExternMethodDeclare = EXTERN SymbolIdentifier ExternParameters [ ExternResult ] [ ExternBind ] .

ExternParameters = "(" [ Types ] ")" .

ExternResult = Type .

ExternBind = MonadBindOperador Identifier .


(* ------------------------------------------------------------------------- *)


(* PROCESSING DIVISION *)

ProcessingDivision = { ProcessingStatement EOL } .

ProcessingStatement = TopLevelSentence 
                    | CommentedStatement .


(* ------------------------------------------------------------------------- *)


(* TESTING DIVISION *)

TestingDivision = { TestingStatement EOL } .

TestingStatement = TopLevelSentence 
                 | CommentedStatement .


(* ------------------------------------------------------------------------- *)


(* NOTE DIVISION *)

NoteDivision = { NoteStatement EOL } .

NoteStatement = CommentedStatement .  (* TODO: ... *)


(* ------------------------------------------------------------------------- *)


(* BOOK DIVISION *)

BookDivision = { BookStatement EOL } .

BookStatement = CommentedStatement .  (* TODO: ... *)


(* ------------------------------------------------------------------------- *)


(* STEREOTYPES & GENERICS *)

StereotypesList = [ AtomStereotypes ]
                  [ GenericsStereotype ] .

GenericsStereotype = "<<" TypeParameters ">>" .

AtomStereotypes = AtomStereotype { [ EOL ] AtomStereotype } .

AtomStereotype = AtomIdentifier [ TaggedValuePairs ]
               | AspectIdentifier [ TaggedValuePairs ]
               .

TaggedValuePairs = TaggedValuePair { "," TaggedValuePair } .

TaggedValuePair = [ Identifier "=" ] Expression .


(* COMMENTS *)

CommentedStatement = CommentStatement
                   | DirectiveStatement
                   | LookupStatement
                   | TestStatement
                   .

Comment = "#" .

LineCommentBegin = Comment .
LineCommentEnd   = EOL .
LineComment      = LineCommentBegin { UnicodePrintable } LineCommentEnd .

BlockCommentBegin = Comment Comment .
BlockCommentEnd   = BlockCommentBegin .
BlockComment      = BlockCommentBegin { Hashtag | UnicodePrintable | EOL } BlockCommentEnd .

CellCommentBegin = Comment Comment Comment .
CellCommentEnd   = CellCommentBegin .
CellComment      = CellCommentBegin { Hashtag | UnicodePrintable | EOL } CellCommentEnd .

CommentContent = LineComment | BlockComment | CellComment .

CommentStatement = CommentContent 
                 | Statement CommentContent .


(* MAGIC COMMENT: HASHTAG *)

Hashtag = Comment Tag { "/" Tag } .


(* MAGIC COMMENT: DIRECTIVE *)

Shebang = Comment "!" .

ShebangInterpreter = Shebang InterpreterPath [ InterpreterArguments ] .

InterpreterPath = FileSystemPath .

InterpreterArguments = { UnicodePrintable } .

PragmaStatement = Shebang { UnicodePrintable } .

DirectiveStatement = ShebangInterpreter
                   | PragmaStatement .


(* MAGIC COMMENT: SHELL LOOKUP *)

Sherlock = Comment UnicodeShell .

LookupStatement = Sherlock Expressions .


(* MAGIC COMMENT: CANARY TESTING *)

Woodstock = Comment "?" .

AssertionTest = Woodstock AssertionExpression .

AssertionExpression = ( Expressions | Statement ) [ "!" [ Expression ] ] .

UnitTest = Woodstock TestSentence .

TestSentence = [ TestDiretives ]
               UnitClause
               [ FromClause ]
               [ OnceClause ]
               [ DataClause ]
               [ CallClause ]
               [ HideClause ]
               [ ShowClause ]
               [ IntoClause ]
               [ PassClause ]
               [ PastClause ]
               [ FailClause ] .

TestDiretives = [ TaggedValuePairs ] EOL .

UnitClause = UNIT [ StringLiteral ] [ StatementSuite ] EOL .

FromClause = FROM [ Expressions | StatementSuite ] EOL .

OnceClause = ONCE [ Expressions | StatementSuite ] EOL .

DataClause = DATA DataSuite EOL .

DataSuite = EOL Indent DataList Dedent .

DataList = { Expression { "|" Expression } EOL  } .

CallClause = CALL [ Expressions | StatementSuite ] EOL .

HideClause = HIDE [ Expressions | StatementSuite ] EOL .

ShowClause = SHOW [ Expressions | StatementSuite ] EOL .

IntoClause = INTO [ Expressions | StatementSuite ] EOL .

PassClause = PASS [ Expressions | StatementSuite ] EOL .

PastClause = PAST [ Expressions | StatementSuite ] EOL .

FailClause = FAIL [ Expressions | StatementSuite ] EOL .

TestStatement = AssertionTest | UnitTest .


(* ------------------------------------------------------------------------- *)


(* TOP LEVEL SENTENCES *)

TopLevelSentence = StereotypesList TopLevelSentence
                 | TypeSentence
                 | DefineSentence
                 | DefnSentence
                 | UnDefineSentence
                 | ConstSentence
                 | IvalSentence
                 | VarSentence
                 | FuncSentence
                 | FactSentence
                 | FmapSentence
                 | FeedSentence
                 | SubSentence
                 | EventSentence
                 | StructSentence
                 | EnumSentence
                 | ProtoSentence
                 | TraitSentence
                 | ClassSentence .


(* TYPE SENTENCE *)

TypeSentence = TYPE ( TypeDeclare | TypeSuite ) .

TypeSuite = EOL Indent TypeDeclareList Dedent .

TypeDeclareList = TypeDeclare { EOL TypeDeclare } .

TypeDeclare = SymbolIdentifier [ GenericTypes ] [ ":" | AS | EXTEND ] Type [ "=" TypeName ] [ MonadBody ] .

MonadBody = EOL Indent MonadMemberDeclaresList Dedent .

MonadMemberDeclaresList = MonadMemberDeclares { EOL MonadMemberDeclares } .

MonadMemberDeclares = MonadMemberDeclare { "," MonadMemberDeclare } .

MonadMemberDeclare = MixinSentence
                   | TopLevelSentence
                   | MonadicValueDeclare .

MonadicValueDeclare = SymbolIdentifier [ "(" TypeParameter ")" ] [ "=" Expression ] .


(* FACT SENTENCE *)

FactSentence = FACT SymbolIdentifier TypeParameters ProcBody .


(* DEFINE SENTENCE *)

DefineSentence = DEFINE ( DefineDeclare | DefineSuite ) .

DefineSuite = EOL Indent DefineDeclareList Dedent .

DefineDeclareList = DefineDeclare { EOL DefineDeclare } .

DefineDeclare = Identifier [ ExpressionDeclarator Expression ] .


(* ??? DEFN SENTENCE ??? *)

DefnSentence = DEFN ( DefnDeclare | DefnSuite ) .

DefnSuite = EOL Indent DefnDeclareList Dedent .

DefnDeclareList = DefnDeclare { EOL DefnDeclare } .

DefnDeclare = Identifier ProcParameters ExpressionDeclarator Expression .


(* UNDEF SENTENCE *)

UnDefineSentence = UNDEF ( UnDefineDeclare | UnDefineSuite ) .

UnDefineSuite = EOL Indent UnDefineDeclareList Dedent .

UnDefineDeclareList = UnDefineDeclare { EOL UnDefineDeclare } . 

UnDefineDeclare = Identifier .


(* CONST SENTENCE *)

ConstSentence = CONST ( VarDeclares | VarSuite ) .


(* IVAL SENTENCE *)

IvalSentence = IVAL ( VarDeclares | VarSuite ) . 


(* VAR SENTENCE *)

VarSentence = VAR ( VarDeclares | VarSuite ) .

VarSuite = EOL Indent VarDeclaresList Dedent .

VarDeclaresList = VarDeclares { EOL VarDeclares } .

VarDeclares = VarDeclare { "," VarDeclare } .

VarDeclare = SymbolIdentifiers [ Type ] [ DeclareAssignment | HeredocLiteral ] .

DeclareAssignment = SingleAssignmentOperator Expressions .


(* FUNC SENTENCE *) 

FuncSentence = FUNC FunctionName [ GenericTypes ] ProcParameters ProcResults ( GuardsSuite | ProcBody ) .

FunctionName = SymbolIdentifier [ "." Identifier ] .

ProcParameters = "(" [ ParmDeclares ] ")"
               | ParmDeclare "=>" { ParmDeclare "=>" } .

ParmDeclares = ParmDeclare { "," ParmDeclare } .

ParmDeclare = [ VAR ] [ ParmIdentifiers ] Type 
            | [ ParmIdentifiers ] Type [ "=" Expression ] .

ParmIdentifiers = ParmIdentifier { "," ParmIdentifier } .

ParmIdentifier = [ AtomStereotypes ] [ PrefixParmModifier ] Identifier .

ProcResults = ResultDeclares | "(" ResultDeclares ")" .

ResultDeclares = ResultDeclare { "," ResultDeclare } .

ResultDeclare = [ ResultIdentifiers ] Type .

ResultIdentifiers = Identifiers .

GuardsSuite = EOL GuardsClause .

ProcBody = ExpressionDeclarator Expressions
         | StatementSuite .


(* FEED SENTENCE *) 

FeedSentence = FEED FunctionName [ GenericTypes ] ProcParameters ( GuardsSuite | ProcBody ) .


(* FMAP SENTENCE *) 

FmapSentence = FMAP FunctionName [ GenericTypes ] ProcParameters [ "=>" ProcResults ] ( GuardsSuite | ProcBody ) .


(* SUB SENTENCE *)

SubSentence = SUB SymbolIdentifier ProcParameters [ ProcResults ] ProcBody .


(* EVENT SENTENCE *)

EventSentence = EVENT SymbolIdentifier EventParameters [ ProcResults ] ProcBody .

EventParameters = "[" [ ParmDeclares ] "]" .


(* ENUM SENTENCE *)

EnumSentence = ENUM SymbolIdentifier [ GenericTypes ] [ GenericTypes ] ProcParameters [ MixinSentence ] EnumBody .

EnumBody = EOL Indent EnumMemberDeclaresList Dedent
         | ":" EnumMemberDeclares .

EnumMemberDeclaresList = EnumMemberDeclares { EOL EnumMemberDeclares } .

EnumMemberDeclares = EnumMemberDeclare { "," EnumMemberDeclare } .

EnumMemberDeclare = MixinSentence
                  | CompositeEnumerationDeclare
                  | TopLevelSentence
                  | CompositeAttributeDeclare
                  | CompositeMethodDeclare .

CompositeEnumerationDeclare = SymbolIdentifier [ EnumArguments ] [ "=" Expression ] .

EnumArguments = "(" Expressions ")" .


(* STRUCT SENTENCE *)

StructSentence = STRUCT SymbolIdentifier [ GenericTypes ] [ MixinSentence ] StructBody .

StructBody = EOL Indent StructMemberDeclaresList Dedent
           | ":" StructMemberDeclares .

StructMemberDeclaresList = StructMemberDeclares { EOL StructMemberDeclares } .

StructMemberDeclares = StructMemberDeclare { "," StructMemberDeclare } .

StructMemberDeclare = MixinSentence
                    | TopLevelSentence
                    | CompositeAttributeDeclare
                    | CompositeMethodDeclare .

CompositeAttributeDeclare = SymbolIdentifiers Type [ AttributeTag ] [ "=" Expressions ]
                          | SymbolIdentifier [ ArraySize ] STRUCT StructBody .

AttributeTag = StringLiteral .

CompositeMethodDeclare = SymbolIdentifier ProcParameters [ ProcResults ] ProcBody .


(* PROTO SENTENCE *)

ProtoSentence = PROTO SymbolIdentifier [ GenericTypes ] [ Implements ] ProtoBody .

ProtoBody = EOL Indent ProtoMethodDeclaresList Dedent
          | ProtoMethodDeclares .

ProtoMethodDeclaresList = ProtoMethodDeclares { EOL ProtoMethodDeclares } .

ProtoMethodDeclares = ProtoMethodDeclare { "," ProtoMethodDeclare } .

ProtoMethodDeclare = AbstractMethodDeclare .

AbstractMethodDeclare = SymbolIdentifier ProcParameters [ ProcResults ] .


(* TRAIT SENTENCE *)

TraitSentence = TRAIT SymbolIdentifier [ GenericTypes ] [ Implements | MixinSentence ] TraitBody .

TraitBody = EOL Indent TraitMemberDeclaresList Dedent
          | TraitMemberDeclares .

TraitMemberDeclaresList = TraitMemberDeclares { EOL TraitMemberDeclares } .

TraitMemberDeclares = TraitMemberDeclare { "," TraitMemberDeclare } .

TraitMemberDeclare = MixinSentence
                   | TopLevelSentence
                   | CompositeAttributeDeclare
                   | CompositeMethodDeclare
                   | CompositeEventDeclare .


(* CLASS & OBJECT SENTENCE *)

ObjectSentence = OBJECT SymbolIdentifier [ GenericTypes ] [ Extends ] [ Implements ] [ MixinSentence ] ClassBody .

ClassSentence = CLASS SymbolIdentifier [ GenericTypes ] [ Extends ] [ Implements ] [ MixinSentence ] ClassBody .

Extends = EXTEND Type .

Implements = IMPLEMENT Types .

ClassBody = EOL Indent ClassMemberDeclaresList Dedent
          | ":" ClassMemberDeclares .

ClassMemberDeclaresList = ClassMemberDeclares { EOL ClassMemberDeclares } .

ClassMemberDeclares = ClassMemberDeclare { "," ClassMemberDeclare } .

ClassMemberDeclare = MixinSentence 
                   | TopLevelSentence
                   | CompositeAttributeDeclare 
                   | AbstractMethodDeclare
                   | CompositeMethodDeclare
                   | CompositeEventDeclare .

CompositeEventDeclare = SymbolIdentifier EventParameters [ ProcResults ] ProcBody .


(* ------------------------------------------------------------------------- *)


(* RUBBER DUCK DEBUGGING *)

RubberDuck = UnicodeAtom { Alphanumeric } "=" .

DebuggingStatement = RubberDuck [ Statement ] .


(* SONGBIRD TRACING *)

SongBird = UnicodeAtom [ LoggingLevel | { Alphanumeric } ] ">" .

LoggingLevel = TRACE | DEBUG | INFO | WARN | ERROR | FATAL .

TracingStatement = SongBird [ Statement ] .


(* STATEMENTS AND BLOCKS *)

StatementSuite = EOL Indent StatementBlock Dedent .

StatementBlock = Statement { EOL Statement } .

Statement      = AtomStereotypes Statement
               | Statement CommandThreadOperator Statement 
               | Label Statement
               | ExpressionStatement
               | EmptyStatement
               | ControlFlowStatement
               | ConditionalStatement
               | LoopingStatement
               | IterationStatement
               | ControlTransferStatement
               | ErrorHandlingStatement
               | ConcurrencyStatement
               | TopLevelSentence
               | DebuggingStatement
               | TracingStatement
               | CommentedStatement .

Label = Identifier ":" .

ExpressionStatement = Expressions .

EmptyStatement = EllipsisOperator .

ClauseStatement = DO Statement
                | StatementSuite
                .


(* CONTROL FLOW STATEMENTS *)

ControlFlowStatement = DeferSentence
                     | WithSentence
                     | OtherwiseSentence
                     | BeginSentence .

DeferSentence = DEFER Statement .

(* WITH SENTENCE *)

WithSentence = WITH Expressions ClauseStatement.

(* OTHERWISE SENTENCE *)

OtherwiseSentence = Statement OTHERWISE Statement .

(* BEGIN SENTENCE *)

BeginSentence = BeginClause 
                FinallyClause
              { CatchClause } .

BeginClause = BEGIN ClauseStatement .

FinallyClause = FINALLY ClauseStatement .

CatchClause = CATCH [ VarDeclares ] ClauseStatement . 


(* CONDITIONAL STATEMENTS *)

ConditionalStatement = IfSentence
                     | UnlessSentence
                     | MatchSentence
                     | TrySentence .

(* IF-ELSE SENTENCE *)

IfSentence = IfThenClause | IfElseClause .

IfThenClause = IF Expression THEN Statement .

IfElseClause = IfClause
             { ElifClause }
             [ ElseClause ] .

IfClause = IF Expression ClauseStatement .

ElifClause = ELIF Expression ClauseStatement .

ElseClause = ELSE ClauseStatement .

(* UNLESS SENTENCE *)

UnlessSentence = UnlessClause .

UnlessClause = Statement UNLESS Expression .

(* MATCH-LIKE-ELSE SENTENCE *)

MatchSentence = MatchClause
                CaseClauses
                [ ElseClause ] .

MatchClause = MATCH Expression [ EOL ] .

CaseClauses = CaseClause
            { CaseClause } .

CaseClause = CASE Expression ClauseStatement .


(* TRY-CATCH SENTENCE *)

TrySentence = TryClause 
              [ ThenClause ]
              CatchClause
              { CatchClause }
              .

TryClause = TRY ( Statement | Expression ) .

ThenClause = THEN ClauseStatement .


(* LOOPING STATEMENTS *)

LoopingStatement = LoopSentence .

(* LOOP SENTENCE *)

LoopSentence = LoopClause
               [ ThenClause ]
               .

LoopClause = LOOP LoopBlock .

LoopBlock = [ LoopCheckFirst ] [ NextClause ] ClauseStatement
          | StatementSuite [ LoopCheckLast ] [ NextClause ] .

LoopCheckFirst = [LoopEachClause] [LoopWhileClause] [LoopUntilClause] [LoopUptoClause] .

LoopCheckLast = [LoopWhileClause] [LoopUntilClause] [LoopUptoClause] .

LoopEachClause = Identifiers EACH Expressions [ STEP Expression ] .

LoopWhileClause = WHILE Expression .

LoopUntilClause = UNTIL Expression .

LoopUptoClause = UPTO Expression .

NextClause = NEXT ( Expression | statement ) .


(* ITERATION STATEMENTS *)

IterationStatement = RedoSentence
                   | ContinueSentence 
                   | BreakSentence .

RedoSentence = REDO [ Label | Expression ] .

ContinueSentence = CONTINUE [ Label | Expression ] .

BreakSentence = BREAK [ Label | Expression ] .


(* CONTROL TRANSFER STATEMENTS *)

ControlTransferStatement = FallthroughSentence
                         | ResumeSentence
                         | ReturnSentence
                         | YieldSentence .

FallthroughSentence = FALLTHROUGH [ Label ] .

ResumeSentence = RESUME [ Label ] .

ReturnSentence = RETURN [ Expressions ] .

YieldSentence = YIELD Expressions .


(* ERROR HANDLING STATEMENTS *)

ErrorHandlingStatement = InvarSentence .

InvarSentence = INVAR [ SymbolIdentifier ] GuardsExpressions .


(* CONCURRENCY STATEMENTS *)

ConcurrencyStatement = GosubSentence
                     | GoToSentence
                     | AwaitSentence
                     | SwitchSentence .


(* GOSUB STATEMENT *)

GosubSentence = GosubClause .

GosubClause = GOSUB StatementSuite .

(* GO TO STATEMENT *)

GoToSentence = ( ConcurrencySingleProcess | ConcurrencyBatchProcess ) [ TO Expression ] .

ConcurrencySingleProcess = GO [ ForksNumber ] ConcurrencyProcess Coroutine .

ConcurrencyBatchProcess = GO [ ForksNumber ] FOR Identifiers EACH BatchData GoBody .

GoBody = EOL Indent GoProcessList Dedent .

GoProcessList = GoProcess EOL { GoProcess } .

GoProcess = ConcurrencyProcess Coroutine .

ForksNumber = Expression .

ConcurrencyProcess = ASYNC | THREAD | TASK | NODE .

Coroutine = Expression .

BatchData = Expression .

(* AWAIT STATEMENT *)

AwaitSentence = AWAIT [ Expressions | ALL ] [ TillCmd ] .

(* SWITCH-WHEN-DEFAULT STATEMENT *)

SwitchSentence = SwitchClause
                 WhenClauses
                 [ DefaultClause ] .

SwitchClause = SWITCH Expressions [ EOL ] .

WhenClauses = WhenClause
            { WhenClause } .

WhenClause = WHEN Expressions ClauseStatement .

DefaultClause = DEFAULT ClauseStatement .


(* ------------------------------------------------------------------------- *)


(* TYPES *)

Type = DecoratedType | ParameterizedType | TypeDeclare | TypeExpression | TypeLiteral | TypeName .

DecoratedType = [ PrefixTypeModifier ] Type [ PosfixTypeModifier ] .

ParameterizedType = Type [ GenericTypes ] . 

TypeDeclare = Types Type.

TypeExpression = Type ( "&" | "|" ) Type .

TypeLiteral = ArrayLiteralType | CompositeLiteralType | FactType | FunctionType | EventType .

TypeName = Identifier | NamespaceIdentifier .

GenericTypes = "<" Types ">" .   // TypeParameters

Types = Type { "," Type } .

(* Arrays *)

ArrayLiteralType = [ ArraySize ] ( ArrayType | ElementType ) .

ArrayType = ParameterizedType . (* array, list, dict, chan, tup, vec, mat, set, que, deq, xml, tab, mem *) 

ElementType = Type .

ArraySize = "[" Expression | RationalLiteral "]" .

(* Composites *)

CompositeLiteralType = ParameterizedType . (* Structs, Protos, Classes *)

(* Facts *)

FactType = FACT FactParameters . 

(* Functions *)

FunctionType = FUNC ProcParameters ProcResults .

(* Events *)

EventType = EVENT EventParameters ProcResults .

(* COMPOUND LITERALS *)

CompoundLiteral = ArrayLiteral | CompositeLiteral .

(* Arrays *)

ArrayLiteral = [ ArrayLiteralType ] ArrayLiteralValue
               | ArrayAosToSoaLiteral 
               | XmlLiteral | ListComprehension.

ArrayLiteralValue = "[" { Element [ "," ] } "]" | "[" "]" .

Element = [ ElementKey ":" ] ElementValue . 

ElementKey = Expression | EscalarLiteral .

ElementValue = Expression | Literal .

ArrayAosToSoaLiteral = "[" "]" Expression .

ListComprehension = "[" Expressions { ComprehensionClause } "]" .

(* Structs *)

CompositeLiteral = [ CompositeLiteralType ] CompositeLiteralValue .  

CompositeLiteralValue = "{" { FieldValue [ "," ] } EOL TraitBody "}" | "{" "}" | "{" "0" "}" .

FieldValue = Identifier [ FieldType ] ":" Literal . 


(* NEOBASIC NATIVE DATA TYPES *)

NeobNativeType = SymbolType | EscalarType | CompoundType | MetaType | ShellType .

EscalarType = BooleanType | NumericType | TemporalType | CharacterType | SequenceType .

CompoundType = CompositeType | ArrayType | ShellType .


(* SYMBOL DATA TYPE *)

SymbolType = ATOM .


(* META DATA TYPES *)

MetaType = ATOM | AUTO | SPAN | VIEW | VOID
         | MODULE | INTERFACE
         | TYPE | FACT | MODIF
         | FUNC | SUB | EVENT 
         | ENUM | STRUCT
         | PROTO | TRAIT | CLASS .

ShellType = PATH | URI | INET .

(* BOOLEAN DATA TYPES *)

BooleanType = BOOL8 | BOOL16 | BOOL32 | BOOL64 | BOOL128 | BOOL .


(* NUMERIC DATA TYPES *)

NumericType = NumericDigit | NumericNatural | NumericInteger
            | NumericDecimal | NumericReal | NumericRatio
            | NumericComplex | NumericQuaternion .

NumericDigit = DIG | BIT | OCT | HEX | NIBBLE .

NumericNatural = NAT8 | NAT16 | NAT32 | NAT64 | NAT128 | BYTE | NAT | BIGNAT .

NumericInteger = INT8 | INT16 | INT32 | INT64 | INT128 | INT | BIGINT .

NumericReal = REAL8 | REAL16 | REAL32 | REAL64 | REAL128 | REAL | BIGREAL .

NumericRatio = RATIO8 | RATIO16 | RATIO32 | RATIO64 | RATIO128 | RATIO .

NumericDecimal = DECIMAL32 | DECIMAL64 | DECIMAL128 | DECIMAL | MONEY .

NumericComplex = COMPLEX32 | COMPLEX64 | COMPLEX128 | COMPLEX .

NumericQuaternion = QUATERN32 | QUATERN64 | QUATERN128 | QUATERN . 


(* TEMPORAL DATA TYPES *)

TemporalType = DATE | ELAPSE .


(* CHARACTER DATA TYPES *)

CharacterType = ASCII | CHAR8 | CHAR16 | CHAR32 | CHAR | WCHAR .


(* SEQUENTIAL DATA TYPES *)

SequenceType = ANSI | STR8 | STR16 | STR32 | STR | CSTR | WSTR | REGEX | BINARY .


(* COMPOSITE DATA TYPES *)

CompositeType = RANGE | PAIR | TUPLE .


(* SHELL DATA TYPES *)

ShellType = PATH | URI | INET .


(* ARRAY DATA TYPES *)

ArrayType = ARRAY | LIST | MAP | CHANNEL | VECTOR | MATRIX | SET | QUEUE | DEQUE | XML | TABLE | MEMO . 


(* MONAD VALUE CONSTRUCTORS *)

MonadValue = BooleanData | NumericData | TemporalData | CharacterData | SequenceData
           | MaybeOption | EitherOption | StreamOption | ResultOption .

BooleanData = TRUE | FALSE .

NumericData = NONZERO | ZERO | MINVALUE | MAXVALUE | NAN | POSITIVEINFINITY | NEGATIVEINFINITY .

TemporalData = LOCALDATE | LOCALDATETIME | OFFSETDATE | OFFSETDATETIME | ZONEDDATE | ZONEDDATETIME
             | TOMORROW | TODAY | NOW | YESTERDAY | EON | EPOCH .

CharacterData = LETTER | MARK | DIGIT | PUNCTUATION | SYMBOL | SEPARATOR | NONPRINTABLE | NULL .

SequenceData = BLANK | NONBLANK .

PathData = FOLDER | FILE | LINKLINKFILE | PIPEFILE | SOCKETFILE
         | BLOCKDEVICE | CHARDEVICE | NULLDEVICE .

UriData = URL | URN .

InetData = IPV4 | IPV6 .

MaybeOption = SOME | NONE .

EitherOption = YEA | NAY .

StreamOption = DATUM | EOT .

ResultOption = OKAY | FAIL .


(* ------------------------------------------------------------------------- *)


(* EXPRESSIONS *)

Expression = UnaryExpression | BinaryExpression | LetExpression | GetExpression | FactExpression
           | EagerEvaluateExpression | CondicionalExpression | FunctorExpression 
           | SoS_Expression .

SoS_Expression = "(" [ Statement | StatementSuite ] ")" .

Expressions = Expression { "," Expression } .

JuxtapositionExpression = Expression { Expression } .

PredeclaredValue = THIS | IOTA | NTH | TOP | END | IT | SELF | SUPER.

FactScope = ALL | ANY | ONE | TWO | NIL .

Literal = EscalarLiteral | CompoundLiteral | LambdaLiteral .

BinaryExpression = Expression BinaryOperator Expression .

AssignmentExpression = Identifiers AssignmentOperator Expressions
                     | Identifier HeredocLiteral .

LetExpression = LET Expression .

GetExpression = GET Expression Expression .

FactExpression = [ FactScope "->" ] Identifier Expressions
               | Expression IS [NOT] [ FactScope "->" ] Identifier .

EagerEvaluateExpression = UnaryEvaluate "(" Expression ")" .

UnaryExpression = PrimaryExpression 
                | PrefixUnaryOperator UnaryExpression 
                | UnaryExpression PosfixUnaryOperator .

FactIdentifier  = Identifier | NamespaceIdentifier .

PrimaryExpression = Operand
                  | Operand ";" Modifier 
                  | Conversion
                  | MethodExpression
                  | PrimaryExpression Selector
                  | PrimaryExpression Indexing
                  | PrimaryExpression Slicing
                  | PrimaryExpression FunctionArguments [ ErrorHandling ]
                  | PrimaryExpression [ FunctionArguments ] LambdaLiteral [ ErrorHandling ] .

Operand = Literal | PredeclaredValue | OperandName [ GenericTypes ] | ShellExpression | "(" Expression ")" .

OperandName = Identifier | NamespaceIdentifier .

Modifier = Identifier .

Conversion = Expression ";" Type .

MethodExpression = ReceiverType "." MethodName .

ReceiverType = Type .

MethodName = Identifier .

Selector = "." Identifier .

Indexing = "[" Expression [ "," ] "]" .

Slicing = "[" SlicingRange [ ";" Expression ] "]" .

SlicingRange = [ Expression [ ">" ] ] ".." [ [ "<" ] Expression ] [ ":" Expression ] .

FunctionArguments = "(" [].

FunctionArguments = "(" [ NamedExpressionList [ "," ] ] ")" .

NamedExpressionList = [ Identifier "=" ] Expression { "," [ Identifier "=" ] Expression } .

ErrorHandling = "!"  [ Expression ] 
              | "!!" Expression
              | "!?" Expression
              | "?"
              | "??" Expression .

CondicionalExpression = IfExpression | UnlessExpression | ForGuardExpression .

IfExpression = Expression IF Expression ELSE Expression .

UnlessExpression = Expression UNLESS Expression ELSE Expression .


FunctorExpression = ForLambdaExpression | ForGuardExpression | ForPipelineExpression .

ForLambdaExpression = FOR [ Expressions ] LambdaLiteral .


ForPipelineExpression = FOR [ Expressions ] PipelinesExpressions .

PipelinesExpressions = { PipelineOperator Expression }+ .


ForGuardExpression = FOR [ Expressions ] GuardsExpressions .

GuardsExpressions = "|" GuardExpression { "|" GuardExpression  } [ "|" Expression ] .

GuardExpression = Expressions ExpressionDeclarator Expression .


(* UNARY OPERATORS *)

UnaryBoolean    = NOT . (* Logical NOT *)

UnaryEvaluate   = "&" . (* Eager Expression or Memory address of a var *)

UnaryArithmetic = "+"  /* Plus sign */
                | "-"  /* Minus sign */
                | "**" /* Square power */
                | "*/" /* Square root */
                | "*!" /* Factorial */
                | "++" /* Increment of a var */
                | "--" /* Decrement of a var */ 
                .

UnaryBitwise    = "~"  /* Bitwise negation */
                | "~~" /* Bitwise negation of a var */
                .

UnarySort       = "^"  /* Sort ascending or descending a data structure */
                | "^^" /* Sort ascending or descending a var */
                .

UnarySpread     = "..." . (* Spread *)

UnaryClone      = "="   /* Shallow copy */
                | "===" /* Deep copy */
                .

UnaryMeta = TYPEOF     /* Type (string) of a var */
          | SIZEOF     /* Number of bytes required for a var or data structure */
          | INSTANCEOF /* Check if an object is an instance of a class */
          .

UnaryArray = EACH       /* Generate an iterator of a iterable var (for loops),
                           or a value converted to text, if not iterable,
                           Generate pipeline with itens of an array */
           | NEW        /* Insert a new item (before other) in a data structure or space in a string */
           | DEL        /* Delete an item of a data structure or a char of a string */
           .

PrefixUnaryOperator  = UnaryBoolean | UnaryEvaluate | UnaryArithmetic | UnaryBitwise
                     | UnarySort | UnarySpread | UnaryMeta | UnaryArray .

PosfixUnaryOperator = UnarySort | UnaryClone .


(* BINARY OPERATORS *)

ArithmeticExpOperator = "**" /* Nth power */
                      | "*/" /* Nth root */
                      .

ArithmeticMultOperator = "*"  /* Multiplication of numbers and strings */
                       | "/"  /* Real Division of numbers, join of paths */
                       | "\\" /* Quotient (Integer division of numbers) */
                       | "%"  /* Remainder (Integer division of numbers) */
                       .

ArithmeticAddOperator = "+" /* Addition of numbers, interpolation of strings */
                      | "-" /* Subtraction */
                      .

PercentageOperator = "%/" /* Percentage Calculation */
                   | "%*" /* Percentage Application */
                   | "%+" /* Percentage Increase */
                   | "%-" /* Percentage Decrease */
                   | "%^" /* Percentage Variation */
                   .

EllipsisOperator = "..." .

BitwiseShiftOperator = "<<"  /* Left shift */
                     | ">>"  /* Right shift */
                     | ">>>" /* Unsigned right shift */
                     .

BitwiseMultOperator = "&"  /* Bitwise AND */
                    | "&~" /* Bitwise bitclear (AND NOT) */
                    .

BitwiseAddOperator = "|" /* Bitwise OR */
                   | "^" /* Bitwise XOR */
                   .

ComparisonOperator = "<=>" /* Three-way comparison */
                   | "?:"  /* Elvis comparison */
                   .

ConcatenationOperator = "." . (* String concatenation *)

RelationalOperator = "=="  /* Strict Equality (test type and value) */
                   | "!="  /* Strict Inequality */
                   | "~==" /* Loose Equality (ignore type and case) */
                   | "~!=" /* Loose Inequality */
                   | "<"   /* Less than */
                   | "<="  /* Less than or equal */
                   | ">"   /* Greater than */
                   | ">="  /* Greater than or equal */
                   .

BinaryBoolean   = AND   /* Logical AND */
                | OR    /* Logical OR */
                | XOR   /* Logical XOR */
                | NAND  /* Logical NAND */
                | NOR   /* Logical NOR */
                | NXOR  /* Logical NXOR */ 
                .

ConditionalOperator = IS        /* Identity Operator */
                    | IN        /* Membership Operator */
                    | BETWEEN   /* Range Operator */
                    | LIKE      /* Pattern Match Operator */
                    | "?%"      /* Evenly Divisible comparison */
                    | "!%"      /* Not Divisible comparison */
                    .

CoalescingOperator = "!!" /* Error coalescing */
                   | "??" /* Exception coalescing */
                   .

PipelineOperator = "|>" . (* Pipeline sequence *)

MonadBindOperador = "=>" .

FunctorInfixOperador = "`" .

BinaryOperator  = ArithmeticExpOperator | ArithmeticMultOperator | ArithmeticAddOperator
                | PercentageOperator | EllipsisOperator
                | BitwiseShiftOperator | BitwiseMultOperator | BitwiseAddOperator
                | ComparisonOperator | ConcatenationOperator
                | RelationalOperator | BinaryBoolean   | ConditionalOperator
                | CoalescingOperator | PipelineOperator
                | MonadBindOperador | FunctorInfixOperador .


(* ASSIGNMENT OPERATORS *)

SingleAssignmentOperator = "="   /* Simple assignment */
                         | ":="  /* Derived declaration assignment  */
                         | "<-"  /* Pop-one assignment */
                         | "<<-" /* Pull-all assignment */
                         | "<|"  /* Pipe assignment */
                         .

CompoundAssignmentOperator = "**="  /* Nth power Compound assignment */
                           | "*/="  /* Nth root Compound assignment */
                           | "*="   /* Multiplication Compound assignment */
                           | "/="   /* Real Division Compound assignment */
                           | "%%="  /* Quotient Compound assignment */
                           | "÷="   /* Quotient Compound assignment */
                           | "%="   /* Remainder Compound assignment */
                           | "+="   /* Addition Compound assignment */
                           | "-="   /* Subtraction Compound assignment */
                           | "%+="  /* Percentage Increase Compound assignment */
                           | "%-="  /* Percentage Decrease Compound assignment */
                           | "<<="  /* Left shift Compound assignment */
                           | ">>="  /* Right shift Compound assignment */
                           | ">>>=" /* Unsigned right shift Compound assignment */
                           | "&="   /* Bitwise AND Compound assignment */
                           | "&^="  /* Bitwise bit Cancel (AND NOT) Compound assignment */
                           | "^="   /* Bitwise XOR Compound assignment */
                           | "|="   /* Bitwise OR Compound assignment */
                           | ".="   /* String concatenation Compound assignment */
                           .

AssignmentOperator = SingleAssignmentOperator | CompoundAssignmentOperator .


(* IMPLICATION OPERATORS *)

NeckRule = ":-" .   (* ??? *)

DiamondOperator = "<>" .   (* ??? *)

RightArrowOperator = "->" .   (* ??? *)

ExpressionDeclarator = ":" . (* One-Liner Suite operator | Implicit return *)


(* PREFIX SYMBOL MODIFIERS *)

VisibilityModifier   = "+" /* Public visibility */
                     | "~" /* Package (or default) visibility */
                     | "-" /* Private visibility */
                     .

LifetimeModifier     = "*" . (* Resource variable Lifetime *)

DerivedModifier      = "/" . (* Derived attribute *)

ReferenceModifier    = "&" . (* Borrowed / pass-by-reference parameter *)

VariadicModifier   = "..." . (* Variadic variable declaration *)

SliceModifier      = ".." . (* Slice array declaration *)

PrefixSymbolModifier = VisibilityModifier | LifetimeModifier | DerivedModifier | VariadicModifier | SliceModifier .

PrefixParmModifier   = ReferenceModifier .


(* PREFIX TYPE MODIFIERS *)

ArrayModifier = "[" [ Expression ] "]" . (* Array variable declaration *) 

PrefixTypeModifier = ArrayModifier .


(* POSFIX TYPE MODIFIERS *)

OptionalModifier       = "!"   /* ResultOption wrapper declaration */
                       | "?"   /* MaybeOption  wrapper declaration */
                       | "??"  /* EitherOption wrapper declaration */
                       | "|>"  /* StreamOption wrapper declaration */
                       | "!?"  /* ResultOption wrapper of MaybeOption wrapper declaration */
                       | "!??" /* ResultOption wrapper of EitherOption wrapper declaration */
                       | "!|>" /* ResultOption wrapper of StreamOption wrapper declaration */
                       .  

ShallowInitialModifier = "=" | "===".

PosfixTypeModifier     = OptionalModifier | ShallowInitialModifier .


(* MULTITHREAD CONTROL FLOW *)

CommandSequence     = "&&" .
CommandSequenceOkay = "?&" .
CommandSequenceFail = "!&" .
CommandBackground   = "||" .

OutputRedirection       = "&>" .
AppendOutputRedirection = "&>>" .

StdoutRedirection       = "&1>" .
AppendStdoutRedirection = "&1>>" .

StderrRedirection       = "&2>" .
AppendStderrRedirection = "&2>>" .

CommandThreadOperator = CommandSequence
                      | CommandSequenceOkay
                      | CommandSequenceFail
                      | CommandBackground
                      | OutputRedirection
                      | AppendOutputRedirection
                      | StdoutRedirection
                      | AppendStdoutRedirection
                      | StderrRedirection
                      | AppendStderrRedirection
                      .


(* ------------------------------------------------------------------------- *)


(* LAMBDA FUNCTION LITERALS *)

LambdaLiteral = LAMBDA [ LambdaParmDeclares ] ExpressionDeclarator Expressions .

LambdaParmDeclares = LambdaParmDeclare { "," LambdaParmDeclare } .

LambdaParmDeclare = Identifiers [ Type ] .


(* XML ARRAY LITERALS *)

XmlElement = "<" XmlTagName [ XmlAttributes ] ">" [ XmlChildren ] "</" XmlTagName ">"
           | "<" XmlTagName "/>" .

XmlTagName = Identifier .

XmlAttributes = { Identifier [ "=" Expression ] } .

XmlChildren = { XmlElement | StringMultiValue } .

XmlLiteral = XmlElement .


(* ESCALAR LITERALS *)

NumericLiteral = NumberLiteral | NaturalLiteral | IntegerLiteral | DecLiteral | RealLiteral
               | ImaginaryLiteral | RationalLiteral . 

RangeLiteral = Expression [ ">" ] ".." [ "<" ] Expression  [ ":" Expression ].

PairLiteral = Expression ":" Expression .

TupleLiteral = "(" Expressions [ "," ] ")" .

ArithmeticComprehension = BinaryOperator "{" Expressions { ComprehensionClause } "}" .

ComprehensionClause = LoopForEachClause [ IF Expression ] .

EscalarLiteral = NumericLiteral | RangeLiteral | PairLiteral | TupleLiteral | ElapseLiteral
               | AsciiLiteral | UnicodeLiteral | StringLiteral | VerbatimLiteral | RegexLiteral
               | XmlElement | AtomLiteral | PromptLiteral | ArithmeticComprehension .


(* UNSIGNED AND SIGNED INTEGER LITERALS *) 

DecimalInteger = DecimalGroups .
BinaryInteger  = "0" ( "b" | "B" ) [ "_" ] BinaryGroups .
OctalInteger   = "0" [ "o" | "O" ] [ "_" ] OctalGroups .
HexInteger     = "0" ( "x" | "X" ) [ "_" ] HexGroups .
RomanInteger   = "0" ( "r" | "R" ) [ "_" ] RomanGroups .

NumberLiteral = ( DecimalInteger | BinaryInteger | OctalInteger | HexInteger | RomanInteger ) . 

NaturalLiteral = NumberLiteral "N" .

IntegerLiteral = [ "+" | "-" ] NumberLiteral .


(* FIXED-POINT AND FLOATING-POINT REAL LITERALS *)

DecimalPoint    = "." .

DecimalMantissa = DecimalGroups DecimalPoint [ DecimalGroups ]
                | DecimalPoint DecimalGroups
                | DecimalGroups .
DecimalExponent = ( "e" | "E" ) [ "+" | "-" ] DecimalGroups .
DecimalReal     = DecimalMantissa [ DecimalExponent ] .

HexMantissa     = [ "_" ] HexGroups DecimalPoint [ HexGroups ]
                | [ "_" ] HexGroups
                | "." HexGroups .
HexExponent     = ( "p" | "P" ) [ "+" | "-" ] DecimalGroups .
HexReal         = "0" ( "x" | "X" ) HexMantissa HexExponent .

DecLiteral      = [ "+" | "-" ] DecimalMantissa "D" .

RealLiteral     = [ "+" | "-" ] ( DecimalReal | HexReal ) .


(* IMAGINARY LITERALS *)

ImaginaryUnit    = "i" | "j" | "k" .
ImaginaryLiteral = ( IntegerLiteral | RealLiteral ) ImaginaryUnit .


(* RATIONAL LITERALS *)

RationalLiteral = IntegerLiteral "//" IntegerLiteral .


(* TEMPORAL LITERALS *)

TimeSuffix = 'ns' | 'us' | 'ms' | 's' | 'min' | 'h' | 'd' | 'w' | 'm' | 'y' .

ElapseLiteral = [ "+" | "-" ] ( IntegerLiteral | RealLiteral ) TimeSuffix .


(* ASCII CHARACTER LITERALS *)

AsciiEscapedControl  = "\\" ( "0" /* 0x00 NULL (NUL) */
                            | "a" /* 0x07 Bell (BEL) */
                            | "b" /* 0x08 Backspace (BS) */
                            | "c" /* 0x03 End of Text (ETX) = Ctrl+C = SIGINT (Interrupt Signal) */
                            | "d" /* 0x04 End of Transmission (EOT) = Ctrl+D = EOF (End Of File) */
                            | "e" /* 0x1B Escape (ESC) */
                            | "f" /* 0x0C Form Feed (FF) */
                            | "n" /* 0x0A Line Feed (LF) */
                            | "q" /* 0x1C File Separator (FS) = Ctrl+\ = SIGQUIT (Quit Signal) */
                            | "r" /* 0x0D Carriage Return (CR) */
                            | "s" /* 0x20 White Space (SP) */
                            | "t" /* 0x09 Horizontal Tab (HT) */
                            | "v" /* 0x0B Vertical Tab (VT) */
                            | "z" /* 0x1A Substitute (SUB) = Ctrl+Z = SIGTSTP (Terminal Stop Signal) */
                            ) .

AsciiEscapedSequence = "\\" ( '"' /* 0x22 Double Quote */
                            | "'" /* 0x27 Single Quote */
                            | "\\" /* 0x5C Backslash */
                            | "`" /* 0x60 Backtick */
                            ) .
AsciiEscapedDecimal = "\\" DecimalDigit DecimalDigit DecimalDigit .
AsciiEscapedBinary  = "\\" "b" BinaryDigit BinaryDigit BinaryDigit BinaryDigit 
                              BinaryDigit BinaryDigit BinaryDigit BinaryDigit .
AsciiEscapedOctal   = "\\" "o" OctalDigit OctalDigit OctalDigit .
AsciiEscapedHex     = "\\" "x" HexDigit HexDigit .

AsciiValue   = AsciiPrintable | AsciiEscapedControl | AsciiEscapedSequence
             | AsciiEscapedDecimal | AsciiEscapedBinary | AsciiEscapedOctal | AsciiEscapedHex .

AsciiCharacter = "'" AsciiValue "'"
               | '"' AsciiValue '"'
               .

AsciiPrefix = "a" .

AsciiLiteral = [ AsciiPrefix ] AsciiCharacter;

(* UNICODE CHARACTER LITERALS *)

UnicodeEscapedShort = "\\" "u" HexDigit HexDigit HexDigit HexDigit .
UnicodeEscapedLong  = "\\" "U" [ HexDigit HexDigit ] HexDigit HexDigit 
                                HexDigit HexDigit   HexDigit HexDigit .

UnicodeEscaped = AsciiEscapedControl | AsciiEscapedSequence | AsciiEscapedDecimal
               | AsciiEscapedBinary | AsciiEscapedOctal | AsciiEscapedHex
               | UnicodeEscapedShort | UnicodeEscapedLong .

UnicodeValue   = UnicodePrintable | AsciiValue
               | UnicodeEscapedShort | UnicodeEscapedLong .

UnicodeCharacter =  "'" UnicodeValue "'"
                 | '"' UnicodeValue '"'
                 .

UnicodePrefix = "L" | "u" | "u8" | "u16" | "u32" .

UnicodeLiteral = [ UnicodePrefix ] UnicodeCharacter .


(* ASCII STRING & UNICODE TEXT LITERALS *)

StringPlaceholder  = "{" Expression [ ";" FormatSpecifiers ] "}" .
FormatSpecifiers   = UnicodeValue { UnicodeValue } .

StringSingleValue = { UnicodeValue | StringPlaceholder } .
StringMultiValue  = { UnicodeValue | StringPlaceholder | EOL } .

StringSequence = "'" StringSingleValue "'"
               | "'''" StringMultiValue "'''"
               .

StringPrefix = AsciiPrefix | UnicodePrefix .

StringLiteral = [ StringPrefix ] StringSequence .


(* VERBATIM LITERALS *)

VerbatimSingleValue = { UnicodePrintable } .
VerbatimMultiValue  = { UnicodePrintable | EOL } .

VerbatimSequence = '"' VerbatimSingleValue '"'
                 | '"""' VerbatimMultiValue '"""'
                 .

VerbatimLiteral = [ StringPrefix ] VerbatimSequence .


(* HEREDOC LITERALS *)

HeredocContent = [ StringPrefix ] "'" [ EOL ] StringMultiValue [ EOL ] "'" 
               | [ StringPrefix ] '"' [ EOL ] VerbatimMultiValue [ EOL ] '"' 
               | Identifier [ EOL ] VerbatimMultiValue [ EOL ] Identifier .

HeredocLiteral = "<<" HeredocContent .


(* REGULAR EXPRESSION LITERALS *)

RegexLiteral = "/" { UnicodeValue } "/" [ { UnicodeValue } ] . 


(* ATOM LITERALS *) 

AtomDotLiteral = UnicodeAtom IntegerLiteral { "." IntegerLiteral } .

AtomCsiLiteral = UnicodeAtom IntegerLiteral { "." IntegerLiteral } "." AsciiPrintable
               | UnicodeAtom AsciiPrintable . 

AtomMusicLiteral = UnicodeAtom MusicAlphabet { "." MusicAlphabet } .

AtomElapseLiteral = UnicodeAtom ElapseLiteral { "." ElapseLiteral } .

AtomLiteral = AtomDotLiteral | AtomCsiLiteral | AtomMusicLiteral | AtomElapseLiteral .


(* PROMPT LITERAL *)

PromptLiteral = UnicodeShell ( StringLiteral | VerbatimLiteral ) .


(* ------------------------------------------------------------------------- *)


(* IDENTIFIERS *)

Tag = Alphanumeric { Alphanumeric } .

Identifier = Letter { Alphanumeric } .

Identifiers = Identifier { "," Identifier } .

NamespaceIdentifier = Identifier { "." Identifier } .

AtomIdentifier = UnicodeAtom Identifier .

AspectIdentifier = UnicodeAtom UnicodeAtom Identifier .

ShellIdentifier = UnicodeShell Identifier .  /* Environment Variable */

ShellString = UnicodeShell ( StringSequence | VerbatimSequence ) .

ShellLiteral = UnicodeShell "_"                 /* Current directory, workspace */
	         | UnicodeShell ("0" | "1" | "2")   /* Standard streams (stdin, stdout, stderr) */
	         | UnicodeShell "%"                 /* All the arguments in an array or string */
	         | UnicodeShell "%" DecimalInteger  /* Nth argument */
	         | UnicodeShell UnicodeShell        /* Process ID (PID) of the NeoBASIC program */
             | FileSystemShell
             | ShellIdentifier
             | ShellString
             .

ShellExpression = ShellLiteral [ ';' Type ] .

ShellExpressions = ShellExpression { "," ShellExpression } .

SymbolIdentifier = AtomStereotypes SymbolIdentifier
                 | PrefixSymbolModifier SymbolIdentifier
                 | Identifier
                 | ShellIdentifier
                 | AtomIdentifier .

SymbolIdentifiers = SymbolIdentifier { "," SymbolIdentifier } .


(* FILE SYSTEM FILES AND DIRECTORIES LITERALS *)

FileSystemShell = UnicodeShell FileSystemPath .

FileSystemPath = AbsolutePath | RelativePath | TildePath .

AbsolutePath = ( "\\" | Letter ":\\" | PathSeparator ) Path .

RelativePath = ( "." PathSeparator  | ".." PathSeparator ) ( { ".." PathSeparator [ Path ] } | Path ) .

TildePath = "~" [ PathSeparator ] Path .

Path = File { PathSeparator File } .

File = PathChar { PathChar } . 

PathChar = UnicodeFilepath | UnicodeEscaped .

PathSeparator = "/" | "\\" . 


(* MUSICAL ALPHABET *) 

MusicAlphabet = MusicNote [ PitchFlat | PitchSharp ] [ OctaveDigit ] .

MusicNote = "A" … "G" .

PitchFlat = "f" .
PitchSharp = "s" .

OctaveDigit = "0" … "8" .


(* TOKENS *)

UnicodeAtom = "@" .

UnicodeShell = "$" .

UnicodeVerb = "%" .

Keyword = Letter { Letter } .


(* LETTERS AND DIGITS *)

Letter        = UnicodeLetter | "_" .
Alphanumeric  = Letter | UnicodeDigit .

DecimalDigit  = UnicodeDigit .
BinaryDigit   = "0" | "1" .
OctalDigit    = "0" … "7" .
HexDigit      = "0" … "9" | "A" … "F" | "a" … "f" .
RomanDigit    = "I"	| "V" | "X"	| "L" | "C"	| "D" | "M" .

DecimalGroups = DecimalDigit { [ "_" ] DecimalDigit } .
BinaryGroups  = BinaryDigit { [ "_" ] BinaryDigit } .
OctalGroups   = OctalDigit { [ "_" ] OctalDigit } .
HexGroups     = HexDigit { [ "_" ] HexDigit } .
RomanGroups   = RomanDigit { [ "_" ] RomanDigit } .


(* UNICODE CHARACTERS *)

AsciiChar   = /* Unicode code points from U+0000 to U+00FF */ .
UnicodeChar = /* Unicode code points from U+0000 to U+10FFFF */ .


(* UNICODE PRINTABLE CHARACTERS *)

UnicodeLetter = /* Unicode code point categorized as (L) Letter */ .
UnicodeDigit  = /* Unicode code point categorized as (Nd) Decimal Number */ .

AsciiPrintable   = (* Unicode code points from U+0000 to U+00FF,
                      except categorized as Cc (Control) *) .

UnicodePrintable = (* Unicode code points from U+0000 to U+10FFFF,
                      except categorized as Cc (Control), Cf (Format), 
                      Cs (Surrogate), Co (Private Use), Cn (Unassigned) *) .

UnicodeFilepath  = (* Unicode code points from U+0000 to U+10FFFF,
                      except categorized as Cc (Control), Cf (Format), 
                      Cs (Surrogate), Co (Private Use), Cn (Unassigned) 
                      and except these 11 chars   "/ \ | < > : ? * \" ' `"   *) . 


(* UNICODE END-OF-LINE AND END-OF-FILE SEPARATORS *) 

UnicodeEOT = /* Unicode code point U+0004 (EOT) End of Transmission Ctrl+D */ .
UnicodeLF  = /* Unicode code point U+000A (LF)  Line Feed */ .
UnicodeCR  = /* Unicode code point U+000D (CR)  Carriage Return */ .
UnicodeSUB = /* Unicode code point U+001A (SUB) Substitute Ctrl+Z */ .
UnicodeNEL = /* Unicode code point U+0085 (NEL) Next Line */ . 
UnicodeLS  = /* Unicode code point U+2028 (LS)  Line Separator */ . 
UnicodePS  = /* Unicode code point U+2029 (PS)  Paragraph Separator */ .

(* End-of-Line *)

EOL = UnicodeCR UnicodeLF /* Windows, DOS */
    | UnicodeLF           /* Unix, Linux, macOS */
    | UnicodeCR           /* Classic Mac OS (pre-OS X) */
    | UnicodeNEL          /* IBM Mainframes (EBCDIC) */
    | UnicodeLS           /* Unicode Line Separator */
    | UnicodePS           /* Unicode Paragraph Separator */
    .

(* End-of-File *)

EOF = UnicodeSUB (* Windows, DOS, Legacy only *)
    | UnicodeEOT (* Unix terminal input *)
    | EOL        (* End-of-Line *)
    .


(* UNICODE WHITE SPACE AND INDENTATION SEPARATORS *)

Indent = UnicodeSP UnicodeSP UnicodeSP UnicodeSP .

Dedent = UnicodeBS UnicodeBS UnicodeBS UnicodeBS .

WSP = UnicodeSP     (* White Space *)
    | UnicodeHT
    | UnicodeVT
    | UnicodeFF
    | UnicodeSpace
    | EOL
    .

UnicodeSP = /* Unicode code point U+0020 (SP) Space */ . 
UnicodeBS = /* Unicode code point U+0008 (BS) Backspace */ .

UnicodeHT = /* Unicode code point U+0009 (HT) Horizontal Tab */ .
UnicodeVT = /* Unicode code point U+000B (VT) Vertical Tab */ .
UnicodeFF = /* Unicode code point U+000C (FF) Form Feed */ .

UnicodeSpace = /* Unicode code point with Property White_Space="Yes",
                  except line break separators code points */ .

(* ------------------------------------------------------------------------- *)
